import { Clan, ClanWar, Player } from '../struct';
import { PollingClientOptions } from '../types';
import { PollingEvents } from '../util/Constants';
import { Client } from './Client';
/**
 * Represents a Polling Event Client.
 * ```js
 * const { PollingClient } = require('clashofclans.js');
 * const pollingClient = new PollingClient({ keys: ['***'] });
 * ```
 * @deprecated The API lacks socket-based real-time events. It is recommended to implement your own custom polling system.
 * Pull data at specified intervals, compare with previous values, and emit events on change.
 * Consider using Node.js clusters for efficient parallel processing.
 */
export declare class PollingClient extends Client {
    private readonly _clanTags;
    private readonly _playerTags;
    private readonly _warTags;
    private readonly _pollingInterval;
    private readonly _clans;
    private readonly _players;
    private readonly _wars;
    private readonly _pollingEvents;
    inMaintenance: boolean;
    private _maintenanceStartTime;
    constructor(options?: PollingClientOptions);
    /** Initialize the PollingEvent Manager to start pulling the data by polling api. */
    init(): Promise<string[]>;
    /** Add clan tags to clan polling events. */
    addClans(tags: string[] | string): this;
    /** Delete clan tags from clan polling events. */
    deleteClans(tags: string[] | string): this;
    /** Add player tags for player polling events. */
    addPlayers(tags: string[] | string): this;
    /** Delete player tags from player polling events. */
    deletePlayers(tags: string[] | string): this;
    /** Add clan tags for war polling events. */
    addWars(tags: string[] | string): this;
    /** Delete clan tags from war polling events. */
    deleteWars(tags: string[] | string): this;
    /**
     * Set your own custom clan polling event.
     *
     * In order to emit the custom polling event, you must have this filter function that returns a boolean.
     *
     * @example
     * ```js
     * client.addClans(['#2PP', '#8QU8J9LP']);
     *
     * client.setClanEvent({
     *   name: 'clanMemberUpdate',
     *   filter: (oldClan, newClan) => {
     *     return oldClan.memberCount !== newClan.memberCount;
     *   }
     * });
     *
     * client.on('clanMemberUpdate', (oldClan, newClan) => {
     *   console.log(oldClan.memberCount, newClan.memberCount);
     * });
     *
     * (async function () {
     *   await client.init();
     * })();
     * ```
     * @returns
     */
    setClanEvent(event: {
        name: string;
        filter: (oldClan: Clan, newClan: Clan) => boolean;
    }): this;
    /**
     * Set your own custom war event.
     *
     * In order to emit the custom event, you must have this filter function that returns a boolean.
     */
    setWarEvent(event: {
        name: string;
        filter: (oldWar: ClanWar, newWar: ClanWar) => boolean;
    }): this;
    /**
     * Set your own custom player event.
     *
     * In order to emit the custom event, you must have this filter function that returns a boolean.
     */
    setPlayerEvent(event: {
        name: string;
        filter: (oldPlayer: Player, newPlayer: Player) => boolean;
    }): this;
    private maintenanceHandler;
    private seasonEndHandler;
    private clanUpdateHandler;
    private playerUpdateHandler;
    private warUpdateHandler;
    private runClanUpdate;
    private runPlayerUpdate;
    private runWarUpdate;
}
export interface PollingClient {
    emit: (<K extends keyof IPollingEvents>(event: K, ...args: IPollingEvents[K]) => boolean) & (<S extends string | symbol>(event: Exclude<S, keyof IPollingEvents>, ...args: any[]) => boolean);
    off: (<K extends keyof IPollingEvents>(event: K, listener: (...args: IPollingEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof IPollingEvents>, listener: (...args: any[]) => void) => this);
    on: (<K extends keyof IPollingEvents>(event: K, listener: (...args: IPollingEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof IPollingEvents>, listener: (...args: any[]) => void) => this);
    once: (<K extends keyof IPollingEvents>(event: K, listener: (...args: IPollingEvents[K]) => void) => this) & (<S extends string | symbol>(event: Exclude<S, keyof IPollingEvents>, listener: (...args: any[]) => void) => this);
    removeAllListeners: (<K extends keyof IPollingEvents>(event?: K) => this) & (<S extends string | symbol>(event?: Exclude<S, keyof IPollingEvents>) => this);
    /**
     * Emits when a new season starts.
     *
     * **Parameters**
     *
     * | Name |   Type   | Description           |
     * | :--: | :------: | :-------------------: |
     * | `id` | `string` | Id of the new season. |
     * @public
     * @event
     */
    newSeasonStart: string;
    /**
     * Emits when maintenance break starts in the API.
     * @public
     * @event
     */
    maintenanceStart: string;
    /**
     * Emits when maintenance break ends in the API.
     *
     * **Parameters**
     *
     * |    Name    |   Type   |                    Description                     |
     * | :--------: | :------: | :------------------------------------------------: |
     * | `duration` | `number` | Duration of the maintenance break in milliseconds. |
     * @public
     * @event
     */
    maintenanceEnd: string;
    /**
     * Emitted for general debugging information.
     * @public
     * @event
     */
    debug: string;
    /**
     * Emitted when the client encounters an error.
     * @public
     * @event
     */
    error: string;
}
interface IPollingEvents {
    [PollingEvents.ClanLoopStart]: [];
    [PollingEvents.ClanLoopEnd]: [];
    [PollingEvents.PlayerLoopStart]: [];
    [PollingEvents.PlayerLoopEnd]: [];
    [PollingEvents.WarLoopStart]: [];
    [PollingEvents.WarLoopEnd]: [];
    [PollingEvents.NewSeasonStart]: [id: string];
    [PollingEvents.MaintenanceStart]: [];
    [PollingEvents.MaintenanceEnd]: [duration: number];
    [PollingEvents.Error]: [error: unknown];
    [PollingEvents.Debug]: [path: string, status: string, message: string];
}
export {};
