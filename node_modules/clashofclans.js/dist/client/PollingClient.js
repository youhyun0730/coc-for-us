"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PollingClient = void 0;
const HTTPError_1 = require("../rest/HTTPError");
const Constants_1 = require("../util/Constants");
const Client_1 = require("./Client");
/**
 * Represents a Polling Event Client.
 * ```js
 * const { PollingClient } = require('clashofclans.js');
 * const pollingClient = new PollingClient({ keys: ['***'] });
 * ```
 * @deprecated The API lacks socket-based real-time events. It is recommended to implement your own custom polling system.
 * Pull data at specified intervals, compare with previous values, and emit events on change.
 * Consider using Node.js clusters for efficient parallel processing.
 */
class PollingClient extends Client_1.Client {
    constructor(options) {
        super(options);
        this._clanTags = new Set();
        this._playerTags = new Set();
        this._warTags = new Set();
        this._clans = new Map();
        this._players = new Map();
        this._wars = new Map();
        this._pollingEvents = {
            clans: [],
            wars: [],
            players: []
        };
        this.inMaintenance = Boolean(false);
        this._maintenanceStartTime = null;
        if (options?.pollingInterval && typeof options.pollingInterval !== 'number') {
            throw new Error('The property "pollingInterval" must be a type of number.');
        }
        this._pollingInterval = Math.max(options?.pollingInterval ?? 1000, 1000);
    }
    /** Initialize the PollingEvent Manager to start pulling the data by polling api. */
    async init() {
        this.seasonEndHandler();
        this.maintenanceHandler();
        this.clanUpdateHandler();
        this.playerUpdateHandler();
        this.warUpdateHandler();
        return Promise.resolve(this.eventNames());
    }
    /** Add clan tags to clan polling events. */
    addClans(tags) {
        for (const tag of Array.isArray(tags) ? tags : [tags]) {
            this._clanTags.add(this.util.formatTag(tag));
        }
        return this;
    }
    /** Delete clan tags from clan polling events. */
    deleteClans(tags) {
        for (const tag of Array.isArray(tags) ? tags : [tags]) {
            const key = this.util.formatTag(tag);
            this._clans.delete(key);
            this._clanTags.delete(key);
        }
        return this;
    }
    /** Add player tags for player polling events. */
    addPlayers(tags) {
        for (const tag of Array.isArray(tags) ? tags : [tags]) {
            this._playerTags.add(this.util.formatTag(tag));
        }
        return this;
    }
    /** Delete player tags from player polling events. */
    deletePlayers(tags) {
        for (const tag of Array.isArray(tags) ? tags : [tags]) {
            const key = this.util.formatTag(tag);
            this._players.delete(key);
            this._playerTags.delete(key);
        }
        return this;
    }
    /** Add clan tags for war polling events. */
    addWars(tags) {
        for (const tag of Array.isArray(tags) ? tags : [tags]) {
            this._warTags.add(this.util.formatTag(tag));
        }
        return this;
    }
    /** Delete clan tags from war polling events. */
    deleteWars(tags) {
        for (const tag of Array.isArray(tags) ? tags : [tags]) {
            const key = this.util.formatTag(tag);
            this._wars.delete(`${key}:${1}`);
            this._wars.delete(`${key}:${2}`);
            this._warTags.delete(key);
        }
        return this;
    }
    /**
     * Set your own custom clan polling event.
     *
     * In order to emit the custom polling event, you must have this filter function that returns a boolean.
     *
     * @example
     * ```js
     * client.addClans(['#2PP', '#8QU8J9LP']);
     *
     * client.setClanEvent({
     *   name: 'clanMemberUpdate',
     *   filter: (oldClan, newClan) => {
     *     return oldClan.memberCount !== newClan.memberCount;
     *   }
     * });
     *
     * client.on('clanMemberUpdate', (oldClan, newClan) => {
     *   console.log(oldClan.memberCount, newClan.memberCount);
     * });
     *
     * (async function () {
     *   await client.init();
     * })();
     * ```
     * @returns
     */
    setClanEvent(event) {
        if (!event.name)
            throw new Error('Event name is required.');
        if (typeof event.filter !== 'function')
            throw new Error('Filter function is required.');
        this._pollingEvents.clans.push(event);
        return this;
    }
    /**
     * Set your own custom war event.
     *
     * In order to emit the custom event, you must have this filter function that returns a boolean.
     */
    setWarEvent(event) {
        if (!event.name)
            throw new Error('Event name is required.');
        if (typeof event.filter !== 'function')
            throw new Error('Filter function is required.');
        this._pollingEvents.wars.push(event);
        return this;
    }
    /**
     * Set your own custom player event.
     *
     * In order to emit the custom event, you must have this filter function that returns a boolean.
     */
    setPlayerEvent(event) {
        if (!event.name)
            throw new Error('Event name is required.');
        if (typeof event.filter !== 'function')
            throw new Error('Filter function is required.');
        this._pollingEvents.players.push(event);
        return this;
    }
    async maintenanceHandler() {
        setTimeout(this.maintenanceHandler.bind(this), this._pollingInterval).unref();
        if (!(this.listenerCount(Constants_1.PollingEvents.MaintenanceStart) && this.listenerCount(Constants_1.PollingEvents.MaintenanceEnd)))
            return;
        try {
            const { res } = await this.rest.getClans({ maxMembers: Math.floor(Math.random() * 40) + 10, limit: 1 });
            if (res.status === 200 && this.inMaintenance) {
                this.inMaintenance = Boolean(false);
                const duration = Date.now() - this._maintenanceStartTime.getTime();
                this._maintenanceStartTime = null;
                this.emit(Constants_1.PollingEvents.MaintenanceEnd, duration);
            }
        }
        catch (error) {
            if (error instanceof HTTPError_1.HTTPError && error.status === 503 && !this.inMaintenance) {
                this.inMaintenance = Boolean(true);
                this._maintenanceStartTime = new Date();
                this.emit(Constants_1.PollingEvents.MaintenanceStart);
            }
        }
    }
    seasonEndHandler() {
        const end = this.util.getSeason().endTime.getTime() - Date.now();
        // Why this? setTimeout can be up to 24.8 days or 2147483647ms [(2^31 - 1) Max 32bit Integer]
        if (end > 24 * 60 * 60 * 1000) {
            setTimeout(this.seasonEndHandler.bind(this), 60 * 60 * 1000);
        }
        else if (end > 0) {
            setTimeout(() => {
                this.emit(Constants_1.PollingEvents.NewSeasonStart, this.util.getSeasonId());
            }, end + 100).unref();
        }
    }
    async clanUpdateHandler() {
        this.emit(Constants_1.PollingEvents.ClanLoopStart);
        for (const tag of this._clanTags)
            await this.runClanUpdate(tag);
        this.emit(Constants_1.PollingEvents.ClanLoopEnd);
        setTimeout(this.clanUpdateHandler.bind(this), this._pollingInterval);
    }
    async playerUpdateHandler() {
        this.emit(Constants_1.PollingEvents.PlayerLoopStart);
        for (const tag of this._playerTags)
            await this.runPlayerUpdate(tag);
        this.emit(Constants_1.PollingEvents.PlayerLoopEnd);
        setTimeout(this.playerUpdateHandler.bind(this), this._pollingInterval);
    }
    async warUpdateHandler() {
        this.emit(Constants_1.PollingEvents.WarLoopStart);
        for (const tag of this._warTags)
            await this.runWarUpdate(tag);
        this.emit(Constants_1.PollingEvents.WarLoopEnd);
        setTimeout(this.warUpdateHandler.bind(this), this._pollingInterval);
    }
    async runClanUpdate(tag) {
        if (this.inMaintenance)
            return null;
        const clan = await this.getClan(tag).catch(() => null);
        if (!clan)
            return null;
        const cached = this._clans.get(clan.tag);
        if (!cached)
            return this._clans.set(clan.tag, clan);
        for (const { name, filter } of this._pollingEvents.clans) {
            try {
                if (!(await filter(cached, clan)))
                    continue;
                this.emit(name, cached, clan);
            }
            catch (error) {
                this.emit(Constants_1.PollingEvents.Error, error);
            }
        }
        return this._clans.set(clan.tag, clan);
    }
    async runPlayerUpdate(tag) {
        if (this.inMaintenance)
            return null;
        const player = await this.getPlayer(tag).catch(() => null);
        if (!player)
            return null;
        const cached = this._players.get(player.tag);
        if (!cached)
            return this._players.set(player.tag, player);
        for (const { name, filter } of this._pollingEvents.players) {
            try {
                if (!(await filter(cached, player)))
                    continue;
                this.emit(name, cached, player);
            }
            catch (error) {
                this.emit(Constants_1.PollingEvents.Error, error);
            }
        }
        return this._players.set(player.tag, player);
    }
    async runWarUpdate(tag) {
        if (this.inMaintenance)
            return null;
        const clanWars = await this.getWars(tag).catch(() => null);
        if (!clanWars?.length)
            return null;
        clanWars.forEach(async (war, index) => {
            const key = `${tag}:${index}`;
            const cached = this._wars.get(key);
            if (!cached)
                return this._wars.set(key, war);
            for (const { name, filter } of this._pollingEvents.wars) {
                try {
                    if (!(await filter(cached, war)))
                        continue;
                    this.emit(name, cached, war);
                }
                catch (error) {
                    this.emit(Constants_1.PollingEvents.Error, error);
                }
            }
            // check for war end
            if (index === 1 && cached.warTag !== war.warTag) {
                const data = await this.getLeagueWar({ clanTag: tag, round: 'PreviousRound' }).catch(() => null);
                if (data && data.warTag === cached.warTag) {
                    for (const { name, filter } of this._pollingEvents.wars) {
                        try {
                            if (!(await filter(cached, data)))
                                continue;
                            this.emit(name, cached, data);
                        }
                        catch (error) {
                            this.emit(Constants_1.PollingEvents.Error, error);
                        }
                    }
                }
            }
            return this._wars.set(key, war);
        });
    }
}
exports.PollingClient = PollingClient;
