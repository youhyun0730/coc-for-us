"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClanWar = exports.WarClan = exports.ClanWarMember = exports.ClanWarAttack = void 0;
const Constants_1 = require("../util/Constants");
const Decorators_1 = require("../util/Decorators");
const Helper_1 = require("../util/Helper");
const Badge_1 = require("./Badge");
/** Represents a Clash of Clans War Attack. */
class ClanWarAttack {
    constructor(clan, war, data) {
        Object.defineProperty(this, 'clan', { value: clan });
        Object.defineProperty(this, 'war', { value: war });
        this.stars = data.stars;
        this.destruction = data.destructionPercentage;
        this.order = data.order;
        this.duration = data.duration;
        this.attackerTag = data.attackerTag;
        this.defenderTag = data.defenderTag;
    }
    /** Returns the defending player. */
    get defender() {
        return this.war.getMember(this.defenderTag);
    }
    /** Returns the attacking player. */
    get attacker() {
        return this.war.getMember(this.attackerTag);
    }
    /** Returns whether the attack is a fresh or first attack on the defender. */
    get isFresh() {
        if (this.defender.defenses.length === 1)
            return true;
        return this.order === Math.min(...this.defender.defenses.map((def) => def.order));
    }
    /**
     * Returns the previous best attack on this opponent village.
     * This is useful for calculating the new stars or destruction for new attacks.
     */
    previousBestAttack() {
        if (this.isFresh)
            return null;
        return (
        // Let's not change the original array
        [...this.clan.attacks]
            .filter((atk) => atk.defenderTag === this.defenderTag && atk.order < this.order && atk.attackerTag !== this.attackerTag)
            .sort((a, b) => b.destruction ** b.stars - a.destruction ** a.stars)
            .at(0) ?? null);
    }
    /** Returns new stars on the defender. */
    get newStars() {
        const prevBest = this.previousBestAttack();
        if (!prevBest)
            return this.stars;
        return Math.max(0, this.stars - prevBest.stars);
    }
}
exports.ClanWarAttack = ClanWarAttack;
/** Represents a Clash of Clans War Member. */
class ClanWarMember {
    constructor(clan, war, data) {
        Object.defineProperty(this, 'clan', { value: clan });
        Object.defineProperty(this, 'war', { value: war });
        this.name = data.name;
        this.tag = data.tag;
        this.mapPosition = data.mapPosition;
        this.townHallLevel = data.townhallLevel;
        this.attacks = data.attacks?.map((atk) => new ClanWarAttack(clan, war, atk)) ?? [];
        this.defenseCount = data.opponentAttacks;
        this._bestOpponentAttackerTag = data.bestOpponentAttack?.attackerTag;
    }
    /** Whether the member is from the opponent clan. */
    get isOpponent() {
        return this.clan.tag === this.war.opponent.tag;
    }
    /** The member's defenses this war. */
    get defenses() {
        return this.war.getDefenses(this.tag);
    }
    /** Best opponent attack on this base. */
    get bestOpponentAttack() {
        if (!this._bestOpponentAttackerTag)
            return null;
        return this.war.getAttack(this._bestOpponentAttackerTag, this.tag);
    }
    /** Get member's formatted link to open member in-game. */
    get shareLink() {
        return `https://link.clashofclans.com/en?action=OpenPlayerProfile&tag=${this.tag.replace(/#/g, '')}`;
    }
    /**
     * Returns the previous best opponent attack on this village.
     * This is useful for calculating the new stars or destruction for new attacks.
     *
     * @deprecated `order` is affecting this method. Use {@link ClanWarAttack#previousBestAttack} instead.
     */
    previousBestOpponentAttack() {
        return (
        // Let's not change the original array
        [...this.defenses]
            .filter((def) => def.defenderTag === this.tag && def.attackerTag !== this.bestOpponentAttack?.attackerTag)
            .sort((a, b) => b.destruction ** b.stars - a.destruction ** a.stars)
            .at(0) ?? null);
    }
}
exports.ClanWarMember = ClanWarMember;
/** Represents a War Clan. */
class WarClan {
    constructor(war, data) {
        Object.defineProperty(this, 'war', { value: war });
        this.name = data.name;
        this.tag = data.tag;
        this.badge = new Badge_1.Badge(data.badgeUrls);
        this.level = data.clanLevel;
        this.stars = data.stars;
        this.attackCount = data.attacks;
        this.destruction = data.destructionPercentage;
        this.members = data.members.map((mem) => new ClanWarMember(this, war, mem));
    }
    /** Whether the clan is the opponent clan. */
    get isOpponent() {
        return this.tag === this.war.opponent.tag;
    }
    /** Average duration of all clan member's attacks. */
    get averageAttackDuration() {
        if (!this.attackCount)
            return 0;
        return this.attacks.reduce((prev, curr) => prev + curr.duration, 0) / this.attackCount;
    }
    /** Returns all clan member's attacks. */
    get attacks() {
        return this.members
            .filter((m) => m.attacks.length)
            .map((m) => m.attacks)
            .flat()
            .sort((a, b) => a.order - b.order);
    }
    /** Returns all clan member's defenses. */
    get defenses() {
        return this.isOpponent ? this.war.clan.attacks : this.war.opponent.attacks;
    }
    /** Get a member of the clan for the given tag, or `null` if not found. */
    getMember(tag) {
        return this.members.find((m) => m.tag === tag) ?? null;
    }
    /** Get a member of the clan for the given map position, or `null` if not found. */
    getMemberByMapPosition(mapPosition) {
        return this.members.find((m) => m.mapPosition === mapPosition) ?? null;
    }
    /** Get clan's formatted link to open clan in-game. */
    get shareLink() {
        return `https://link.clashofclans.com/en?action=OpenClanProfile&tag=${this.tag.replace(/#/g, '')}`;
    }
}
exports.WarClan = WarClan;
/**
 * Represents a Clan War in Clash of Clans.
 *
 * :::caution
 * It's recommended to see if ClanWar#state is `notInWar` available before performing operations or reading data from it. You can check this with data.ok property.
 * :::
 */
class ClanWar {
    constructor(client, data, extra) {
        this.client = client;
        this.state = data.state;
        if (this.state !== 'notInWar') {
            this.teamSize = data.teamSize;
            this.attacksPerMember = data.attacksPerMember ?? (extra.warTag ? 1 : 2);
            this.preparationStartTime = client.util.formatDate(data.preparationStartTime);
            this.startTime = client.util.formatDate(data.startTime);
            this.endTime = client.util.formatDate(data.endTime);
            this.warTag = extra.warTag ?? null;
            let [clan, opponent] = [data.clan, data.opponent];
            const clanTag = extra.clanTag && client.util.formatTag(extra.clanTag);
            if (clanTag && [data.clan.tag, data.opponent.tag].includes(clanTag)) {
                clan = data.clan.tag === clanTag ? data.clan : data.opponent;
                opponent = data.clan.tag === clan.tag ? data.opponent : data.clan;
            }
            this.clan = new WarClan(this, clan);
            this.opponent = new WarClan(this, opponent);
        }
    }
    /** Return a {@link ClanWarMember} with the tag provided. */
    getMember(tag) {
        return this.clan.getMember(tag) ?? this.opponent.getMember(tag) ?? null;
    }
    /** Return a list of {@link ClanWarAttack} for the attackerTag and defenderTag provided. */
    getAttack(attackerTag, defenderTag) {
        const attacker = this.getMember(attackerTag);
        if (!attacker?.attacks.length)
            return null;
        return attacker.attacks.find((atk) => atk.defenderTag === defenderTag) ?? null;
    }
    /** Return a list of {@link ClanWarAttack} for the defenderTag provided. */
    getDefenses(defenderTag) {
        const defender = this.getMember(defenderTag);
        if (defender.isOpponent) {
            return this.clan.attacks.filter((atk) => atk.defenderTag === defenderTag);
        }
        return this.opponent.attacks.filter((atk) => atk.defenderTag === defenderTag);
    }
    /** Whether the clan is not in war. */
    get isNotInWar() {
        return this.state === 'notInWar';
    }
    /** Whether this is a Battle Day. */
    get isBattleDay() {
        return this.state === 'inWar';
    }
    /** Whether this is a Preparation Day. */
    get isPreparationDay() {
        return this.state === 'preparation';
    }
    /** Whether this War has Ended. */
    get isWarEnded() {
        return this.state === 'warEnded';
    }
    /** Returns either `friendly`, `cwl` or `normal`. */
    get type() {
        if (this.isFriendly)
            return 'friendly';
        if (this.warTag)
            return 'cwl';
        return 'normal';
    }
    /** Whether this is a friendly war. */
    get isFriendly() {
        const preparationTime = this.startTime.getTime() - this.preparationStartTime.getTime();
        return Constants_1.FriendlyWarPreparationTimes.includes(preparationTime);
    }
    /** Whether this is a CWL. */
    get isCWL() {
        return typeof this.warTag === 'string';
    }
    /** Whether this is a normal war. */
    get isNormal() {
        return !this.isCWL && !this.isFriendly;
    }
    /** Returns the war status, based off the home clan. */
    get status() {
        if (this.state === 'preparation')
            return 'pending';
        return (0, Helper_1.getWarResult)({
            stars: this.clan.stars,
            destructionPercentage: this.clan.destruction
        }, {
            stars: this.opponent.stars,
            destructionPercentage: this.opponent.destruction
        });
    }
    /** Returns the Clan War League Group. */
    getClanWarLeagueGroup() {
        if (!this.isCWL)
            return null;
        return this.client.getClanWarLeagueGroup(this.clan.tag);
    }
}
exports.ClanWar = ClanWar;
__decorate([
    (0, Decorators_1.Enumerable)(false)
], ClanWar.prototype, "client", void 0);
