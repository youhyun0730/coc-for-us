"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchThrottler = exports.QueueThrottler = void 0;
const Util_1 = require("../util/Util");
/**
 * Represents a throttler that sleeps for x ms between each request.
 * ```js
 * const throttler = new QueueThrottler(1000 / 10);
 * // 10 requests per second or sleep for 100ms between each request.
 * ```
 */
class QueueThrottler {
    constructor(sleepTime = 100) {
        this.generator = this.init();
        this.sleepTime = sleepTime;
    }
    async *init() {
        let lastRan = 0;
        // eslint-disable-next-line
        while (true) {
            const difference = Date.now() - lastRan;
            const needToSleep = this.sleepTime - difference;
            if (needToSleep > 0)
                await Util_1.Util.delay(needToSleep);
            lastRan = Date.now();
            yield;
        }
    }
    async wait() {
        return this.generator.next();
    }
}
exports.QueueThrottler = QueueThrottler;
/**
 * Represents a throttler that allows x requests per second before sleeping until the next second.
 * ```js
 * const throttler = new BatchThrottler(15);
 * // 15 requests every second.
 * ```
 */
class BatchThrottler {
    constructor(rateLimit = 15, sleepTime = 1000) {
        this.generator = this.init();
        this.rateLimit = rateLimit;
        this.sleepTime = sleepTime;
    }
    async *init() {
        let count = 0;
        // eslint-disable-next-line
        while (true) {
            if (count++ >= this.rateLimit) {
                if (this.sleepTime > 0)
                    await Util_1.Util.delay(this.sleepTime);
                count = 0;
            }
            yield;
        }
    }
    async wait() {
        return this.generator.next();
    }
}
exports.BatchThrottler = BatchThrottler;
